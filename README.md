# 5-Stage RV32I Pipelined RISC-V CPU Core

A modular, synthesizable CPU core implementing the RV32I ISA in Verilog with a classic 5-stage pipeline and basic hazard handling. Demonstrates IF, ID, EX, MEM, and WB stages, with an inline instruction ROM and IF/ID registers.

---

##  Features

- **5-Stage Pipeline**: IF → ID → EX → MEM → WB  
- **RV32I Instruction Set**: `ADDI`, `ADD`, `SUB`, `LW`, `SW`, `BEQ`, `JAL`  
- **Hazard Handling**: Basic forwarding and stall insertion  
- **Inline Instruction ROM**: No external `.hex` required  
- **Waveform Demo**: Captured entirely in GTKWave via EDA-Playground  

---

## Folder Structure

    riscv-pipeline-cpu/
    ├── src/                 # Verilog source modules
    │   ├── pc.v             # Program Counter
    │   ├── instruction_mem.v# Inline Instruction ROM
    │   ├── if_id_regs.v     # IF/ID pipeline register
    │   ├── cpu_top.v        # Top-level IF stage module
    │   └── ...              # (future: ID/EX, EX/MEM, MEM/WB registers)
    ├── docs/                # Diagrams & waveforms
    │   └── gtk_waveform.png # IF stage waveform capture
    └── README.md            # Project overview (this file)

---
##  IF stage Waveforms 


 Captured from EDA-Playground’s GTKWave showing program counter, fetched instruction, and IF/ID registers over time:

 ![IF Stage Waveform](https://raw.githubusercontent.com/hyeonjijung1/riscv-pipeline-cpu/main/docs/waveforms/if_stage_waveform.png)
---
## ID→EX Pipeline Waveforms

Captured from EDA-Playground’s GTKWave, this shows how control signals, immediates, and register addresses flow through the ID→EX boundary:

![ID→EX Waveform]([docs/waveforms/id_ex_stage_waveform.png](https://github.com/hyeonjijung1/riscv-pipeline-cpu/blob/main/docs/waveforms/ID_EX_pipeline.png))

| Signal               | Description                                                      |
|----------------------|------------------------------------------------------------------|
| `instr_id`           | Fetched instruction entering the ID stage                        |
| `RegWrite`, `MemRead`, etc. | Control bits generated by the Control Unit (ADDI, ADD, SW, LW, JAL patterns) |
| `imm_id`             | Sign-extended immediate produced by the immediate generator      |
| `rs1_addr`, `rs2_addr` | Source register indices decoded from `instr_id`                 |
| `rs1_data`, `rs2_data` | Data read from the register file (zero until writeback stage)   |
| `*_ex` signals       | All of the above latched one cycle later in `id_ex_regs`         |

### How to interpret

1. **Reset** held high → all `*_ex` signals are `X`.  
2. **Cycle 1**:  
   - `instr_id = 0x00000293` (ADDI)  
   - Control = `ALUSrc=1`, `ALUOp=00`, `RegWrite=1`  
   - `imm_id = 0` (I-type), `rs1_addr=0`, `rs2_addr=0`  
   - At the rising edge, these values snapshot into the `*_ex` buses.  
3. **Cycles 2–5**:  
   - Subsequent instructions (ADD, SW, LW, JAL) produce the correct control bits and immediates, each transferred through the pipeline register.  

This demonstrates correct ID-stage behavior:  
- Decoding opcodes into control signals  
- Generating and sign-extending immediates  
- Reading register addresses and data  
- Latching all outputs into `id_ex_regs` for the EX stage  
,,

##  How to Demo

 **Open in EDA-Playground** (no local tools required)  
   - Use Icarus Verilog + EPWave configuration  
   - Paste the **entire Verilog design + testbench** into the left pane  
   - Run and capture the waveform  


